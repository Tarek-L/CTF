

# This file was *autogenerated* from the file chal.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0xcaffe = Integer(0xcaffe); _sage_const_3 = Integer(3); _sage_const_0xc0ffee = Integer(0xc0ffee); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_9 = Integer(9); _sage_const_10 = Integer(10); _sage_const_11 = Integer(11); _sage_const_12 = Integer(12); _sage_const_13 = Integer(13); _sage_const_14 = Integer(14); _sage_const_15 = Integer(15); _sage_const_16 = Integer(16); _sage_const_17 = Integer(17); _sage_const_18 = Integer(18); _sage_const_19 = Integer(19); _sage_const_20 = Integer(20); _sage_const_21 = Integer(21); _sage_const_22 = Integer(22); _sage_const_23 = Integer(23); _sage_const_24 = Integer(24); _sage_const_25 = Integer(25); _sage_const_26 = Integer(26); _sage_const_27 = Integer(27); _sage_const_28 = Integer(28); _sage_const_29 = Integer(29); _sage_const_30 = Integer(30); _sage_const_31 = Integer(31); _sage_const_32 = Integer(32); _sage_const_0 = Integer(0)
import random
from base64 import b64encode, b64decode
from functools import reduce

SEED = int(_sage_const_0xcaffe  *_sage_const_3 * _sage_const_0xc0ffee )

# https://people.maths.bris.ac.uk/~matyd/GroupNames/61/Q8s5D4.html
G = PermutationGroup([
    [(_sage_const_1 ,_sage_const_2 ,_sage_const_3 ,_sage_const_4 ),(_sage_const_5 ,_sage_const_6 ,_sage_const_7 ,_sage_const_8 ),(_sage_const_9 ,_sage_const_10 ,_sage_const_11 ,_sage_const_12 ),(_sage_const_13 ,_sage_const_14 ,_sage_const_15 ,_sage_const_16 ),(_sage_const_17 ,_sage_const_18 ,_sage_const_19 ,_sage_const_20 ),(_sage_const_21 ,_sage_const_22 ,_sage_const_23 ,_sage_const_24 ),(_sage_const_25 ,_sage_const_26 ,_sage_const_27 ,_sage_const_28 ),(_sage_const_29 ,_sage_const_30 ,_sage_const_31 ,_sage_const_32 )],
    [(_sage_const_1 ,_sage_const_24 ,_sage_const_3 ,_sage_const_22 ),(_sage_const_2 ,_sage_const_23 ,_sage_const_4 ,_sage_const_21 ),(_sage_const_5 ,_sage_const_14 ,_sage_const_7 ,_sage_const_16 ),(_sage_const_6 ,_sage_const_13 ,_sage_const_8 ,_sage_const_15 ),(_sage_const_9 ,_sage_const_27 ,_sage_const_11 ,_sage_const_25 ),(_sage_const_10 ,_sage_const_26 ,_sage_const_12 ,_sage_const_28 ),(_sage_const_17 ,_sage_const_31 ,_sage_const_19 ,_sage_const_29 ),(_sage_const_18 ,_sage_const_30 ,_sage_const_20 ,_sage_const_32 )],
    [(_sage_const_1 ,_sage_const_5 ,_sage_const_12 ,_sage_const_30 ),(_sage_const_2 ,_sage_const_6 ,_sage_const_9 ,_sage_const_31 ),(_sage_const_3 ,_sage_const_7 ,_sage_const_10 ,_sage_const_32 ),(_sage_const_4 ,_sage_const_8 ,_sage_const_11 ,_sage_const_29 ),(_sage_const_13 ,_sage_const_25 ,_sage_const_19 ,_sage_const_21 ),(_sage_const_14 ,_sage_const_26 ,_sage_const_20 ,_sage_const_22 ),(_sage_const_15 ,_sage_const_27 ,_sage_const_17 ,_sage_const_23 ),(_sage_const_16 ,_sage_const_28 ,_sage_const_18 ,_sage_const_24 )],
    [(_sage_const_1 ,_sage_const_26 ),(_sage_const_2 ,_sage_const_27 ),(_sage_const_3 ,_sage_const_28 ),(_sage_const_4 ,_sage_const_25 ),(_sage_const_5 ,_sage_const_14 ),(_sage_const_6 ,_sage_const_15 ),(_sage_const_7 ,_sage_const_16 ),(_sage_const_8 ,_sage_const_13 ),(_sage_const_9 ,_sage_const_23 ),(_sage_const_10 ,_sage_const_24 ),(_sage_const_11 ,_sage_const_21 ),(_sage_const_12 ,_sage_const_22 ),(_sage_const_17 ,_sage_const_31 ),(_sage_const_18 ,_sage_const_32 ),(_sage_const_19 ,_sage_const_29 ),(_sage_const_20 ,_sage_const_30 )]
])
num2e = [*G]
e2num = {y:x for x,y in enumerate(num2e)}
b64encode_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0987654321+/"
b64decode_map = {c:i for i,c in enumerate(b64encode_map)}

def gen_random_mat(seed: int, size: int):
    random.seed(seed)
    return matrix(size, size, random.choices([_sage_const_0 ,_sage_const_1 ], k=size*size))

def mat_vec_mul(mat, vec):
    return [reduce(lambda x,y: x*y, (a**b for a,b in zip(vec, m))) for m in mat]

def hash_msg(msg: bytes):
    emsg = b64encode(msg).decode().strip("=")
    sz = len(emsg)
    vec = [num2e[b64decode_map[c]] for c in emsg]
    mat = gen_random_mat(SEED, sz)
    for _ in range(_sage_const_10 ):
        # Since G is non-abelian, this is a pretty good hash function!
        vec = mat_vec_mul(mat, vec)
    return ''.join((b64encode_map[e2num[c]] for c in vec))

if __name__ == "__main__":
    from flag import flag # secret!!
    import re

    assert re.match(r"^grey\{.+\}$", flag.decode())
    ct = hash_msg(flag)
    print(ct)

# Program output:
# aO3qDbHFoittWTN6MoUYw9CZiC9jdfftFGw1ipES89ugOwk2xCUzDpPdpBWtBP3yarjNOPLXjrMODD

