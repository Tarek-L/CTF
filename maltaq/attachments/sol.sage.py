

# This file was *autogenerated* from the file sol.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1825310437373651425737133387514704339138752170433274546111276309 = Integer(1825310437373651425737133387514704339138752170433274546111276309); _sage_const_42423271339336624024407863370989392004524790041279794366407913985192411875865 = Integer(42423271339336624024407863370989392004524790041279794366407913985192411875865); _sage_const_2 = Integer(2); _sage_const_255 = Integer(255); _sage_const_19 = Integer(19); _sage_const_45 = Integer(45); _sage_const_4 = Integer(4); _sage_const_1401 = Integer(1401); _sage_const_2048 = Integer(2048); _sage_const_1273 = Integer(1273); _sage_const_1 = Integer(1); _sage_const_500 = Integer(500); _sage_const_501 = Integer(501); _sage_const_0 = Integer(0); _sage_const_16 = Integer(16)# Lean & fast SageMath script for full flag recovery (k0 + k1)
from sage.all import *

# --- Constants ---
h1 = _sage_const_1825310437373651425737133387514704339138752170433274546111276309 
h3 = _sage_const_42423271339336624024407863370989392004524790041279794366407913985192411875865 
p = _sage_const_2 **_sage_const_255  - _sage_const_19 
FLAG_LEN = _sage_const_45 
k0_bytes = FLAG_LEN//_sage_const_2  + _sage_const_4 
k1_bytes = FLAG_LEN - k0_bytes
PREFIX = b"maltactf{"

# --- k0 Recovery ---
a, b, c, d = _sage_const_1401 , _sage_const_2 , -_sage_const_2048 , _sage_const_1273 
G = matrix(ZZ, [[a, b], [c, d]])
tr, det = a + d, a*d - b*c
lam = (tr + sqrt(tr**_sage_const_2  - _sage_const_4 *det)) / _sage_const_2 
alpha = log(lam, _sage_const_2 )
beta = log(a / lam, _sage_const_2 ) + _sage_const_1 
n_est = floor((h1 - beta) / alpha)

for offset in range(-_sage_const_500 , _sage_const_501 ):
    k0 = n_est + offset
    try:
        if (G**k0)[_sage_const_0 ,_sage_const_0 ].nbits() == h1:
            part = Integer(k0).to_bytes(k0_bytes, 'big')
            if part.startswith(PREFIX):
                first = part.decode('ascii')
                break
    except:
        continue
else:
    raise ValueError("k0 not found")

# --- k1 Recovery ---
Fp = GF(p)
tr1 = Fp(tr)
det1 = Fp(det)
inv_b = Fp(b).inverse()
target = Fp(h3) * inv_b

# Recurrence: u_n = tr1*u_{n-1} - det1*u_{n-2}
B = _sage_const_1  << _sage_const_16 
u = [Fp(_sage_const_0 ), Fp(_sage_const_1 )]
baby = {u[_sage_const_0 ]: _sage_const_0 , u[_sage_const_1 ]: _sage_const_1 }
for j in range(_sage_const_2 , B):
    nxt = tr1*u[_sage_const_1 ] - det1*u[_sage_const_0 ]
    baby[nxt] = j
    u = [u[_sage_const_1 ], nxt]

C = companion_matrix([det1, -tr1])
CB = C**B
vec = vector(Fp, [_sage_const_1 , _sage_const_0 ])
for i in range(B+_sage_const_1 ):
    if vec[_sage_const_0 ] in baby:
        k1 = i*B + baby[vec[_sage_const_0 ]]
        break
    vec = CB * vec
else:
    raise ValueError("k1 not found")

suffix = Integer(k1).to_bytes(k1_bytes, 'big').decode('ascii', 'replace')
print("\nFull flag:", first + suffix)


