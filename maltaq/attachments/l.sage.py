

# This file was *autogenerated* from the file l.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1401 = Integer(1401); _sage_const_2 = Integer(2); _sage_const_2048 = Integer(2048); _sage_const_1273 = Integer(1273); _sage_const_45 = Integer(45); _sage_const_4 = Integer(4); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_100 = Integer(100)# SageMath script to recover k0 from noisy bit length leak
from sage.all import matrix, ZZ, log, floor, sqrt, Integer

# Step 1: Define known values
G = matrix(ZZ, [[_sage_const_1401 , _sage_const_2 ], [-_sage_const_2048 , _sage_const_1273 ]])
h1 = Integer("1825310437373651425737133387514704339138752170433274546111276309")

# Step 2: Estimate the size of k0
FLAG_LEN = _sage_const_45   # Length of full flag
K0_BYTES = (FLAG_LEN // _sage_const_2 ) + _sage_const_4   # = 26
PREFIX = b"maltactf{"  # Known prefix to match

# Step 3: Spectral analysis of G to find growth rate
tr = G[_sage_const_0 ,_sage_const_0 ] + G[_sage_const_1 ,_sage_const_1 ]
det = G.det()
disc = tr**_sage_const_2  - _sage_const_4 *det
lam1 = (tr + sqrt(disc)) / _sage_const_2 

alpha = log(lam1, _sage_const_2 )
A1 = G[_sage_const_0 ,_sage_const_0 ]  # G^1[0][0]
C = A1 / lam1
beta = log(C, _sage_const_2 ) + _sage_const_1 

# Step 4: Invert to get estimate for k0
n_real = (h1 - beta) / alpha
n_est = floor(n_real)

# Step 5: Brute force a small window around the estimate
window = _sage_const_100   # Search window
print("Estimated k0 near:", n_est)

for k in range(n_est - window, n_est + window + _sage_const_1 ):
    try:
        b = Integer(k).to_bytes(K0_BYTES, 'big')
    except OverflowError:
        continue
    if b.startswith(PREFIX):
        print("Found potential k0:")
        print("k0 =", k)
        print("bytes =", b)
        print("ascii =", b.decode(errors='replace'))
        break
else:
    print("No match found in the search window.")


