

# This file was *autogenerated* from the file sol.sage
from sage.all_cmdline import *   # import sage library

_sage_const_7434459989309917390 = Integer(7434459989309917390); _sage_const_13764883950722179945 = Integer(13764883950722179945); _sage_const_6491039561529571699 = Integer(6491039561529571699); _sage_const_13576977941708037180 = Integer(13576977941708037180); _sage_const_2 = Integer(2); _sage_const_64 = Integer(64); _sage_const_59 = Integer(59); _sage_const_10 = Integer(10); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_8 = Integer(8)
from Crypto.Cipher import AES
from binascii import unhexlify

# Known values from out.txt
outputs = [
    _sage_const_7434459989309917390 ,
    _sage_const_13764883950722179945 ,
    _sage_const_6491039561529571699 ,
    _sage_const_13576977941708037180 
]

ciphertext_hex = "5c285fcff21cadb30a6ec92d445e5d75898f83fc31ff395cb43fb8be319d464895cf9aed809c20f92eb6f79f6bd36fc8d3091725b54c889a22850179ec26f89c"
ciphertext = unhexlify(ciphertext_hex)

MOD64 = _sage_const_2 **_sage_const_64  - _sage_const_59 
max_k = _sage_const_10   # how many lifted candidates to try

# Generate lifted candidates for internal state
lifted_states = []
for y in outputs:
    lifted_states.append([y + k * MOD64 for k in range(max_k)])

# Try all combinations of lifted states
for x0 in lifted_states[_sage_const_0 ]:
    for x1 in lifted_states[_sage_const_1 ]:
        for x2 in lifted_states[_sage_const_2 ]:
            for x3 in lifted_states[_sage_const_3 ]:
                try:
                    a = (x2 - x1) / (x1 - x0)
                    c = x1 - a * x0
                    # m can be computed using x3 = (a * x2 + c) % m â‡’ m = a*x2 + c - x3
                    m_candidate = (a * x2 + c) - x3
                    if not m_candidate.is_integer():
                        continue
                    m = Integer(m_candidate)
                    if m <= _sage_const_0  or not is_prime(m):
                        continue


                    # Validate the recurrence
                    def fwd(x): return (a * x + c) % m
                    test = [int(fwd(x0)) % MOD64 == outputs[_sage_const_1 ],
                            int(fwd(fwd(x0))) % MOD64 == outputs[_sage_const_2 ],
                            int(fwd(fwd(fwd(x0)))) % MOD64 == outputs[_sage_const_3 ]]
                    if all(test):
                        print(f"[+] Found LCG params:\na = {int(a)}\nc = {int(c)}\nm = {int(m)}")

                        # Recover key = get_blocks(2) = first two outputs
                        k1 = int(x0) % MOD64
                        k2 = int(fwd(x0)) % MOD64
                        key = k1.to_bytes(_sage_const_8 , 'big') + k2.to_bytes(_sage_const_8 , 'big')
                        print(f"[+] AES Key = {key.hex()}")

                        # Decrypt
                        cipher = AES.new(key, AES.MODE_ECB)
                        flag = cipher.decrypt(ciphertext)
                        print("[+] Flag:", flag.strip())
                        quit()
                except ZeroDivisionError:
                    continue

print("[-] No valid parameters found.")


